
{
    
    
    
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2023-10-03","image":"","imageAlt":"","link":"https://bl9.github.io/posts/benchmarking-aws-ec2-nvme-storage/","summary":"A practical guide to benchmarking AWS EC2 NVMe storage performance using fio. Learn the differences between EBS volumes and instance store, decode fio output, and understand IOPS, throughput, and latency.","tags":["aws","benchmarking","devops","ebs","ec2","fio","nvme","performance","storage"],"text":"quick primer: ebs vs instance store before we start throwing benchmarks around, let\u0026rsquo;s clarify what we\u0026rsquo;re actually testing here.\ninstance store nvme: this is the physical ssd attached directly to your ec2 host. think of it as the internal hard drive of your server. it\u0026rsquo;s blazingly fast because there\u0026rsquo;s no network in the way. the catch? it\u0026rsquo;s ephemeral - if your instance stops or terminates, poof, your data is gone. perfect for caches, temporary processing, or anything you can rebuild.\nebs (elastic block store): this is network-attached storage that persists independently of your instance. it\u0026rsquo;s like having an external drive that you can unplug from one computer and attach to another. more flexible, but there\u0026rsquo;s a network hop involved which affects performance.\nebs volume types: the simple version aws offers several ebs types, and honestly, the naming could be better:\ngp3 (general purpose ssd) - the new default and probably what you want 99% of the time. you get 3,000 iops and 125 mb/s baseline, and you can tune iops and throughput independently. it\u0026rsquo;s like ordering a burger where you can customize the toppings separately from the patty size.\ngp2 (general purpose ssd) - the old default. iops scale with volume size (3 iops per gb), which means you sometimes had to buy a bigger volume just to get more performance. kind of like having to order a large drink to get free refills.\nio2/io2 block express - for when you need serious, consistent iops. we\u0026rsquo;re talking up to 64,000 iops per volume (or 256,000 with block express). these are expensive and you\u0026rsquo;ll know if you need them. think databases with heavy random i/o patterns.\nst1 (throughput optimized hdd) - spinning disks optimized for sequential throughput. good for big data workloads where you\u0026rsquo;re reading large files sequentially. cheaper, but slow for random access.\nsc1 (cold hdd) - the budget option for infrequently accessed data. if you\u0026rsquo;re considering this, you might want to think about s3 instead.\nbenchmarking with fio fio (flexible i/o tester) is the de facto standard for storage benchmarking. it\u0026rsquo;s powerful, which also means it has about a million options. this post will only discuss the basics of it.\nfirst, install it:\n# amazon linux / rhel / centos sudo yum install -y fio # ubuntu / debian sudo apt-get install -y fio a real-world benchmark here\u0026rsquo;s a benchmark i run regularly to get a feel for storage performance. this tests random read/write with a 4k block size, which mimics what most databases do:\nsudo fio --name=random-rw \\ --ioengine=libaio \\ --iodepth=32 \\ --rw=randrw \\ --rwmixread=70 \\ --bs=4k \\ --direct=1 \\ --size=4g \\ --numjobs=4 \\ --runtime=60 \\ --group_reporting \\ --filename=/dev/nvme1n1 let me break down what this actually does:\n--name=random-rw: just a label for this test --ioengine=libaio: use linux native async i/o (fast and realistic) --iodepth=32: keep 32 i/o operations in flight simultaneously --rw=randrw: random read and write mixed together --rwmixread=70: 70% reads, 30% writes (typical for many apps) --bs=4k: 4 kilobyte blocks (database-like workload) --direct=1: bypass os cache (we want to test the actual disk) --size=4g: test with 4gb of data --numjobs=4: run 4 parallel jobs (simulate concurrent access) --runtime=60: run for 60 seconds --filename=/dev/nvme1n1: the device to test decoding the fio output when fio finishes, it dumps a wall of text at you. here\u0026rsquo;s what actually matters:\nrandom-rw: (groupid=0, jobs=4): err= 0: pid=1234: tue oct 3 14:30:00 2023 read: iops=12.5k, bw=48.8mib/s (51.2mb/s)(2932mib/60001msec) slat (usec): min=2, max=15234, avg=23.45, stdev=89.23 clat (usec): min=45, max=98234, avg=1876.34, stdev=2345.67 lat (usec): min=51, max=98256, avg=1899.79, stdev=2348.12 write: iops=5357, bw=20.9mib/s (21.9mb/s)(1256mib/60001msec) slat (usec): min=3, max=24567, avg=34.56, stdev=123.45 clat (usec): min=67, max=145678, avg=2234.56, stdev=3456.78 lat (usec): min=73, max=145701, avg=2269.12, stdev=3459.23 iops (input/output operations per second): how many read or write operations the disk can handle per second. higher is better. in this example, we\u0026rsquo;re getting 12.5k read iops and 5.3k write iops.\nbw (bandwidth/throughput): how much data we\u0026rsquo;re actually moving. in this case, 48.8 mib/s for reads and 20.9 mib/s for writes. this is the \u0026ldquo;how fast can i copy files\u0026rdquo; number.\nlatency numbers (this is where it gets interesting):\nslat (submission latency): time to submit the i/o request to the kernel clat (completion latency): time waiting for the i/o to complete lat (total latency): the full round trip time - this is what you feel the avg (average) latency is important, but the max tells you about those annoying hiccups. in the example above, average read latency is ~1.9ms, but max spiked to 98ms. that spike is what makes your app feel sluggish occasionally.\n","title":"Benchmarking EC2 NVMe Storage: EBS vs Instance Store Performance"},{"date":"2023-07-03","image":"","imageAlt":"","link":"https://bl9.github.io/posts/introduction-to-nix/","summary":"A practical introduction to Nix package manager covering basics, nix repl, derivations, channels, and profiles with hands-on examples.","tags":["devops","linux","macos","nix","nixpkgs","package-manager","tutorial"],"text":"introduction to nix nix is great but the learning curve is a bit steep and it takes time to start building production stuff with it. nevertheless, i\u0026rsquo;d say the best way to learn is to start your own configuration and build on top of that.\nin this article, i will be dissecting the basics of nix and will be going through number of basic and simple recipes that can be done with nix. i am planning to add more in the future.\nlet\u0026rsquo;s start by exploring different scenario in nix repl:\n‚ùØ nix repl welcome to nix 2.13.3. type :? for help. nix-repl\u0026gt; loading all nix expressions and adding them to current scope:\nnix-repl\u0026gt; :l \u0026lt;nixpkgs\u0026gt; added 19653 variables. to list and count the loaded packages:\nnix-repl\u0026gt; builtins.length(builtins.attrnames pkgs) 19654 nix-repl\u0026gt; builtins.attrnames pkgs [ \u0026#34;aaaaaasomethingsfailtoevaluate\u0026#34; \u0026#34;amb-plugins\u0026#34; \u0026#34;archisteamfarm\u0026#34; .. ] if you\u0026rsquo;re wondering about the builtins functions, you can simply ready the documentation about that within the repl:\nnix-repl\u0026gt; :doc builtins.attrnames synopsis: builtins.attrnames set return the names of the attributes in the set set in an alphabetically sorted list. for instance, builtins.attrnames { y = 1; x = \u0026#34;foo\u0026#34;; } evaluates to [ \u0026#34;x\u0026#34; \u0026#34;y\u0026#34; ]. to verify if pkgs is a set:\nnix-repl\u0026gt; :doc builtins.isattrs synopsis: builtins.isattrs e return true if e evaluates to a set, and false otherwise. nix-repl\u0026gt; builtins.isattrs pkgs true note: if you are like me wondering how pkgs was implicitly defined, i believe it\u0026rsquo;s because it\u0026rsquo;s defined in the nixpkgs upstream so you can pull the packages from pkgs folder/variable.\nanother question is why \u0026lt;nixpkgs\u0026gt; used instead of nixpkgs directly, why \u0026lt;\u0026gt; is needed? ü§î\nit looks like\n‚ùØ nix-instantiate --eval --expr \u0026#39;\u0026amp;lt;nixpkgs\u0026gt;\u0026#39; /users/s0x/.nix-defexpr/channels/nixpkgs # or: # nix-repl\u0026gt; \u0026lt;nixpkgs\u0026gt; # /users/s0x/.nix-defexpr/channels/nixpkgs so based on the above, it tells us that \u0026lt;nixpkgs\u0026gt; is an expression used to search for nixpkgs in the nix paths that are defined in the environment variables ($nix_path or -i). another proof:\n‚ùØ nix-instantiate --eval --expr \u0026#39;\u0026amp;lt;mew\u0026gt;\u0026#39; error: file \u0026#39;mew\u0026#39; was not found in the nix search path (add it using $nix_path or -i) at ¬´string¬ª:1:1: 1| \u0026lt;mew\u0026gt; | ^ let\u0026rsquo;s try and build python derivation:\nnix-repl\u0026gt; :b python310 this derivation produced the following outputs: out -\u0026gt; /nix/store/m4kmky8ay96qwyakxjmj1idcvrdmvb9k-python3-3.10.12 we can verify the built derivation by accessing the python shell after *exiting the nix repl:\n‚ùØ /nix/store/m4kmky8ay96qwyakxjmj1idcvrdmvb9k-python3-3.10.12/bin/python python 3.10.12 (main, aug 31 2023, 13:04:33) [clang 11.1.0 ] on darwin type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; nix-repl\u0026gt; :b python311.withpackages(p: [p.requests]) this derivation produced the following outputs: out -\u0026gt; /nix/store/bl65mjkcchgamgqw1zw9ns46p4gpi1wh-python3-3.11.4-env # exit nix repl ‚ùØ /nix/store/bl65mjkcchgamgqw1zw9ns46p4gpi1wh-python3-3.11.4-env/bin/python python 3.11.4 (main, aug 31 2023, 13:04:34) [clang 11.1.0 ] on darwin type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import requests \u0026gt;\u0026gt;\u0026gt; nix closure is the nix\u0026rsquo;s package dependency tree. it includes all the packages required to build and run the package.\nchannels a channel is a git repository containing a list of packages.\n‚ùØ nix-channel --list darwin https://github.com/lnl7/nix-darwin/archive/master.tar.gz nixpkgs https://github.com/nixos/nixpkgs/archive/staging-next.tar.gz profiles profiles are groups of generations so that different users don‚Äôt interfere with each other if they don‚Äôt want to. profiles and user environments are nix‚Äôs mechanisms to allow different users to use different configurations.\nderivation a derivation is a nix expression describing everything that goes into a package build action (build tools, dependencies, sources, build scripts, environment variables). it is anything needed to build up a package\n","title":"Introduction to Nix: Getting Started with Nix Package Manager"}]
}

