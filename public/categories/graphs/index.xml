<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Graphs on Bl9 Rambling</title>
    <link>https://bl9.github.io/categories/graphs/</link>
    <description>Recent content in Graphs on Bl9 Rambling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Dec 2025 14:55:06 -0500</lastBuildDate><atom:link href="https://bl9.github.io/categories/graphs/index.xml" rel="self" type="application/rss+xml" /><icon>https://bl9.github.io/img/icon.svg</icon>
    
    
    <item>
      <title>Ucs Shortest Path Algorithm</title>
      <link>https://bl9.github.io/posts/ucs-shortest-path-algorithm/</link>
      <pubDate>Sun, 07 Dec 2025 14:55:06 -0500</pubDate>
      
      <guid>https://bl9.github.io/posts/ucs-shortest-path-algorithm/</guid>
      <description><![CDATA[<p>UCS is a shortest path algorith that&rsquo;s similar to Dijkstra algorithm. The only difference is that UCS will terminate as soon as it finds the goal node, while Dijkstra will continue to explore all possible paths until it has found the shortest path to all nodes in the graph.</p>
<p>So based on that, to implement UCS, we can use a priority queue to keep track of the nodes to be explored, sorted by their cumulative cost from the start node. We will also maintain a set of visited nodes to avoid processing the same node multiple times.</p>
<p>To summarize the steps of UCS algorithm:</p>
<ol>
<li>Initialize a priority queue with the start node and a cumulative cost of 0.</li>
<li>While the priority queue is not empty:
a. Dequeue the node with the lowest cumulative cost.
b. If the node is the goal node, return the cumulative cost as the shortest path cost.
c. If the node has not been visited:
i. Mark the node as visited.
ii. For each neighbor of the node, calculate the cumulative cost to reach that neighbor and enqueue it in the priority queue.</li>
</ol>
<p>Here&rsquo;s an example for simple UCS implementation in python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> heapq
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>edges <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>weights <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_edge</span>(self, from_node, to_node, weight):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>edges[from_node]<span style="color:#f92672">.</span>append(to_node)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>weights[(from_node, to_node)] <span style="color:#f92672">=</span> weight
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ucs</span>(graph, start, goal):
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, start)]
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>        (cost, node) <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(queue)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        visited<span style="color:#f92672">.</span>add(node)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node <span style="color:#f92672">==</span> goal:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cost
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> neighbor <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>edges[node]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> neighbor <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>                total_cost <span style="color:#f92672">=</span> cost <span style="color:#f92672">+</span> graph<span style="color:#f92672">.</span>weights[(node, neighbor)]
</span></span><span style="display:flex;"><span>                heapq<span style="color:#f92672">.</span>heappush(queue, (total_cost, neighbor))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> float(<span style="color:#e6db74">&#34;inf&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph()
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;D&#39;</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#e6db74">&#39;D&#39;</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>start <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>
</span></span><span style="display:flex;"><span>goal <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;D&#39;</span>
</span></span><span style="display:flex;"><span>cost <span style="color:#f92672">=</span> ucs(g, start, goal)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;The cost of the shortest path from </span><span style="color:#e6db74">{</span>start<span style="color:#e6db74">}</span><span style="color:#e6db74"> to </span><span style="color:#e6db74">{</span>goal<span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{</span>cost<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>)
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
  </channel>
</rss>
