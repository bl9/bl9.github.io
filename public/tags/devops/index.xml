<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>Devops on Bl9 Rambling</title>
    <link>http://localhost:1313/tags/devops/</link>
    <description>Recent content in Devops on Bl9 Rambling</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Oct 2023 14:20:00 -0500</lastBuildDate><atom:link href="http://localhost:1313/tags/devops/index.xml" rel="self" type="application/rss+xml" /><icon>http://localhost:1313/img/icon.svg</icon>
    
    
    <item>
      <title>Benchmarking EC2 NVMe Storage: EBS vs Instance Store Performance</title>
      <link>http://localhost:1313/posts/benchmarking-aws-ec2-nvme-storage/</link>
      <pubDate>Tue, 03 Oct 2023 14:20:00 -0500</pubDate>
      
      <guid>http://localhost:1313/posts/benchmarking-aws-ec2-nvme-storage/</guid>
      <description><![CDATA[<h2 id="quick-primer-ebs-vs-instance-store">Quick Primer: EBS vs Instance Store</h2>
<p>Before we start throwing benchmarks around, let&rsquo;s clarify what we&rsquo;re actually testing here.</p>
<p><strong>Instance Store NVMe</strong>: This is the physical SSD attached directly to your EC2 host. Think of it as the internal hard drive of your server. It&rsquo;s blazingly fast because there&rsquo;s no network in the way. The catch? It&rsquo;s ephemeral - if your instance stops or terminates, poof, your data is gone. Perfect for caches, temporary processing, or anything you can rebuild.</p>
<p><strong>EBS (Elastic Block Store)</strong>: This is network-attached storage that persists independently of your instance. It&rsquo;s like having an external drive that you can unplug from one computer and attach to another. More flexible, but there&rsquo;s a network hop involved which affects performance.</p>
<h3 id="ebs-volume-types-the-simple-version">EBS Volume Types: The Simple Version</h3>
<p>AWS offers several EBS types, and honestly, the naming could be better:</p>
<p><strong>gp3 (General Purpose SSD)</strong> - The new default and probably what you want 99% of the time. You get 3,000 IOPS and 125 MB/s baseline, and you can tune IOPS and throughput independently. It&rsquo;s like ordering a burger where you can customize the toppings separately from the patty size.</p>
<p><strong>gp2 (General Purpose SSD)</strong> - The old default. IOPS scale with volume size (3 IOPS per GB), which means you sometimes had to buy a bigger volume just to get more performance. Kind of like having to order a large drink to get free refills.</p>
<p><strong>io2/io2 Block Express</strong> - For when you need serious, consistent IOPS. We&rsquo;re talking up to 64,000 IOPS per volume (or 256,000 with Block Express). These are expensive and you&rsquo;ll know if you need them. Think databases with heavy random I/O patterns.</p>
<p><strong>st1 (Throughput Optimized HDD)</strong> - Spinning disks optimized for sequential throughput. Good for big data workloads where you&rsquo;re reading large files sequentially. Cheaper, but slow for random access.</p>
<p><strong>sc1 (Cold HDD)</strong> - The budget option for infrequently accessed data. If you&rsquo;re considering this, you might want to think about S3 instead.</p>
<h2 id="benchmarking-with-fio">Benchmarking with fio</h2>
<p><code>fio</code> (Flexible I/O Tester) is the de facto standard for storage benchmarking. It&rsquo;s powerful, which also means it has about a million options. This post will only discuss the basics of it.</p>
<p>First, install it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Amazon Linux / RHEL / CentOS</span>
</span></span><span style="display:flex;"><span>sudo yum install -y fio
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Ubuntu / Debian</span>
</span></span><span style="display:flex;"><span>sudo apt-get install -y fio
</span></span></code></pre></div><h3 id="a-real-world-benchmark">A Real-World Benchmark</h3>
<p>Here&rsquo;s a benchmark I run regularly to get a feel for storage performance. This tests random read/write with a 4K block size, which mimics what most databases do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fio --name<span style="color:#f92672">=</span>random-rw <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --ioengine<span style="color:#f92672">=</span>libaio <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --iodepth<span style="color:#f92672">=</span><span style="color:#ae81ff">32</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --rw<span style="color:#f92672">=</span>randrw <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --rwmixread<span style="color:#f92672">=</span><span style="color:#ae81ff">70</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --bs<span style="color:#f92672">=</span>4k <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --direct<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --size<span style="color:#f92672">=</span>4G <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --numjobs<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --runtime<span style="color:#f92672">=</span><span style="color:#ae81ff">60</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --group_reporting <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --filename<span style="color:#f92672">=</span>/dev/nvme1n1
</span></span></code></pre></div><p>Let me break down what this actually does:</p>
<ul>
<li><code>--name=random-rw</code>: Just a label for this test</li>
<li><code>--ioengine=libaio</code>: Use Linux native async I/O (fast and realistic)</li>
<li><code>--iodepth=32</code>: Keep 32 I/O operations in flight simultaneously</li>
<li><code>--rw=randrw</code>: Random read AND write mixed together</li>
<li><code>--rwmixread=70</code>: 70% reads, 30% writes (typical for many apps)</li>
<li><code>--bs=4k</code>: 4 kilobyte blocks (database-like workload)</li>
<li><code>--direct=1</code>: Bypass OS cache (we want to test the actual disk)</li>
<li><code>--size=4G</code>: Test with 4GB of data</li>
<li><code>--numjobs=4</code>: Run 4 parallel jobs (simulate concurrent access)</li>
<li><code>--runtime=60</code>: Run for 60 seconds</li>
<li><code>--filename=/dev/nvme1n1</code>: The device to test</li>
</ul>
<h3 id="decoding-the-fio-output">Decoding the fio Output</h3>
<p>When fio finishes, it dumps a wall of text at you. Here&rsquo;s what actually matters:</p>
<pre tabindex="0"><code>random-rw: (groupid=0, jobs=4): err= 0: pid=1234: Tue Oct  3 14:30:00 2023
  read: IOPS=12.5k, BW=48.8MiB/s (51.2MB/s)(2932MiB/60001msec)
    slat (usec): min=2, max=15234, avg=23.45, stdev=89.23
    clat (usec): min=45, max=98234, avg=1876.34, stdev=2345.67
     lat (usec): min=51, max=98256, avg=1899.79, stdev=2348.12
  write: IOPS=5357, BW=20.9MiB/s (21.9MB/s)(1256MiB/60001msec)
    slat (usec): min=3, max=24567, avg=34.56, stdev=123.45
    clat (usec): min=67, max=145678, avg=2234.56, stdev=3456.78
     lat (usec): min=73, max=145701, avg=2269.12, stdev=3459.23
</code></pre><p><strong>IOPS (Input/Output Operations Per Second)</strong>: How many read or write operations the disk can handle per second. Higher is better. In this example, we&rsquo;re getting 12.5k read IOPS and 5.3k write IOPS.</p>
<p><strong>BW (Bandwidth/Throughput)</strong>: How much data we&rsquo;re actually moving. In this case, 48.8 MiB/s for reads and 20.9 MiB/s for writes. This is the &ldquo;how fast can I copy files&rdquo; number.</p>
<p><strong>Latency Numbers</strong> (this is where it gets interesting):</p>
<ul>
<li><code>slat</code> (submission latency): Time to submit the I/O request to the kernel</li>
<li><code>clat</code> (completion latency): Time waiting for the I/O to complete</li>
<li><code>lat</code> (total latency): The full round trip time - <strong>this is what you feel</strong></li>
</ul>
<p>The <code>avg</code> (average) latency is important, but the <code>max</code> tells you about those annoying hiccups. In the example above, average read latency is ~1.9ms, but max spiked to 98ms. That spike is what makes your app feel sluggish occasionally.</p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Introduction to Nix: Getting Started with Nix Package Manager</title>
      <link>http://localhost:1313/posts/introduction-to-nix/</link>
      <pubDate>Mon, 03 Jul 2023 15:30:00 -0500</pubDate>
      
      <guid>http://localhost:1313/posts/introduction-to-nix/</guid>
      <description><![CDATA[<h2 id="introduction-to-nix">Introduction to Nix</h2>
<p>Nix is great but the learning curve is a bit steep and it takes time to start building production stuff with it. Nevertheless, I&rsquo;d say the best way to learn is to start your own configuration and build on top of that.</p>
<p>In this article, I will be dissecting the basics of Nix and will be going through number of basic and simple recipes that can be done with <code>nix</code>. I am planning to add more in the future.</p>
<p>Let&rsquo;s start by exploring different scenario in <code>nix repl</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚ùØ</span> nix repl
</span></span><span style="display:flex;"><span>Welcome to Nix <span style="color:#ae81ff">2</span><span style="color:#ae81ff">.13.3</span><span style="color:#f92672">.</span> Type :<span style="color:#f92672">?</span> for help<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>Loading all nix expressions and adding them to current scope:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> :l <span style="color:#e6db74">&lt;nixpkgs&gt;</span>
</span></span><span style="display:flex;"><span>Added <span style="color:#ae81ff">19653</span> variables<span style="color:#f92672">.</span>
</span></span></code></pre></div><p>To list and count the loaded packages:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> builtins<span style="color:#f92672">.</span>length(builtins<span style="color:#f92672">.</span>attrNames pkgs)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19654</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> builtins<span style="color:#f92672">.</span>attrNames pkgs
</span></span><span style="display:flex;"><span>[ <span style="color:#e6db74">&#34;AAAAAASomeThingsFailToEvaluate&#34;</span> <span style="color:#e6db74">&#34;AMB-plugins&#34;</span> <span style="color:#e6db74">&#34;ArchiSteamFarm&#34;</span>  <span style="color:#f92672">..</span> ]
</span></span></code></pre></div><p>If you&rsquo;re wondering about the <code>builtins</code> functions, you can simply ready the documentation about that within the repl:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> :doc builtins<span style="color:#f92672">.</span>attrNames
</span></span><span style="display:flex;"><span>Synopsis: builtins<span style="color:#f92672">.</span>attrNames set
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Return the names of the attributes in the set set in an alphabetically sorted list<span style="color:#f92672">.</span> For instance<span style="color:#960050;background-color:#1e0010">,</span> builtins<span style="color:#f92672">.</span>attrNames { y <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;foo&#34;</span>; } evaluates to [ <span style="color:#e6db74">&#34;x&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;y&#34;</span> ]<span style="color:#f92672">.</span>
</span></span></code></pre></div><p>To verify if <code>pkgs</code> is a set:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> :doc builtins<span style="color:#f92672">.</span>isAttrs
</span></span><span style="display:flex;"><span>Synopsis: builtins<span style="color:#f92672">.</span>isAttrs e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Return <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">if</span> e evaluates to a set<span style="color:#960050;background-color:#1e0010">,</span> and <span style="color:#66d9ef">false</span> otherwise<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> builtins<span style="color:#f92672">.</span>isAttrs pkgs
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">true</span>
</span></span></code></pre></div><p><strong>Note:</strong> <em>If you are like me wondering how <code>pkgs</code> was implicitly defined, I believe it&rsquo;s because it&rsquo;s defined in the <code>nixpkgs</code> upstream so you can pull the packages from <code>pkgs</code> folder/variable.</em></p>
<p>Another question is why <code>&lt;nixpkgs&gt;</code> used instead of <code>nixpkgs</code> directly, why <code>&lt;&gt;</code> is needed? ü§î</p>
<p>It looks like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚ùØ</span> nix-instantiate <span style="color:#960050;background-color:#1e0010">--</span>eval <span style="color:#960050;background-color:#1e0010">--</span>expr <span style="color:#960050;background-color:#1e0010">&#39;&amp;</span>lt;nixpkgs<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/Users/s0x/.nix-defexpr/channels/nixpkgs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># OR:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># nix-repl&gt; &lt;nixpkgs&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># /Users/s0x/.nix-defexpr/channels/nixpkgs</span>
</span></span></code></pre></div><p>So based on the above, it tells us that <code>&lt;nixpkgs&gt;</code> is an expression used to search for <code>nixpkgs</code> in the Nix paths that are defined in the environment variables (<code>$NIX_PATH or -I</code>). Another proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚ùØ</span> nix-instantiate <span style="color:#960050;background-color:#1e0010">--</span>eval <span style="color:#960050;background-color:#1e0010">--</span>expr <span style="color:#960050;background-color:#1e0010">&#39;&amp;</span>lt;mew<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">&#39;</span>
</span></span><span style="display:flex;"><span>error: file <span style="color:#960050;background-color:#1e0010">&#39;</span>mew&#39; was not found in the Nix search path (add it using <span style="color:#960050;background-color:#1e0010">$</span>NIX_PATH or <span style="color:#960050;background-color:#1e0010">-</span>I)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       at <span style="color:#960050;background-color:#1e0010">¬´</span>string<span style="color:#960050;background-color:#1e0010">¬ª</span>:<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#e6db74">&lt;mew&gt;</span>
</span></span><span style="display:flex;"><span>             <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#960050;background-color:#1e0010">^</span>
</span></span></code></pre></div><p>Let&rsquo;s try and build python derivation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> :b python310
</span></span><span style="display:flex;"><span>This derivation produced the following outputs:
</span></span><span style="display:flex;"><span>  out <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">/nix/store/m4kmky8ay96qwyakxjmj1idcvrdmvb9k-python3-3.10.12</span>
</span></span></code></pre></div><p>We can verify the built derivation by accessing the python shell after *exiting the <code>nix repl</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>‚ùØ /nix/store/m4kmky8ay96qwyakxjmj1idcvrdmvb9k-python3-3.10.12/bin/python
</span></span><span style="display:flex;"><span>Python 3.10.12 <span style="color:#f92672">(</span>main, Aug <span style="color:#ae81ff">31</span> 2023, 13:04:33<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>Clang 11.1.0 <span style="color:#f92672">]</span> on darwin
</span></span><span style="display:flex;"><span>Type <span style="color:#e6db74">&#34;help&#34;</span>, <span style="color:#e6db74">&#34;copyright&#34;</span>, <span style="color:#e6db74">&#34;credits&#34;</span> or <span style="color:#e6db74">&#34;license&#34;</span> <span style="color:#66d9ef">for</span> more information.
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>nix-repl<span style="color:#f92672">&gt;</span> :b python311<span style="color:#f92672">.</span>withPackages(p: [p<span style="color:#f92672">.</span>requests])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>This derivation produced the following outputs:
</span></span><span style="display:flex;"><span>  out <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">/nix/store/bl65mjkcchgamgqw1zw9ns46p4gpi1wh-python3-3.11.4-env</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># exit nix repl</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚ùØ</span> <span style="color:#e6db74">/nix/store/bl65mjkcchgamgqw1zw9ns46p4gpi1wh-python3-3.11.4-env/bin/python</span>
</span></span><span style="display:flex;"><span>Python <span style="color:#ae81ff">3</span><span style="color:#ae81ff">.11.4</span> (main<span style="color:#960050;background-color:#1e0010">,</span> Aug <span style="color:#ae81ff">31</span> <span style="color:#ae81ff">2023</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#ae81ff">13</span>:<span style="color:#ae81ff">04</span>:<span style="color:#ae81ff">34</span>) [Clang <span style="color:#ae81ff">11</span><span style="color:#ae81ff">.1.0</span> ] on darwin
</span></span><span style="display:flex;"><span>Type <span style="color:#e6db74">&#34;help&#34;</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#e6db74">&#34;copyright&#34;</span><span style="color:#960050;background-color:#1e0010">,</span> <span style="color:#e6db74">&#34;credits&#34;</span> or <span style="color:#e6db74">&#34;license&#34;</span> for more information<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> requests
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>Nix Closure is the Nix&rsquo;s package dependency tree. It includes all the packages required to build and run the package.</p>
<p>Channels
A channel is a git repository containing a list of packages.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚ùØ</span> nix-channel <span style="color:#960050;background-color:#1e0010">--</span>list
</span></span><span style="display:flex;"><span>darwin <span style="color:#e6db74">https://github.com/LnL7/nix-darwin/archive/master.tar.gz</span>
</span></span><span style="display:flex;"><span>nixpkgs <span style="color:#e6db74">https://github.com/NixOS/nixpkgs/archive/staging-next.tar.gz</span>
</span></span></code></pre></div><p>Profiles
Profiles are groups of generations so that different users don‚Äôt interfere with each other if they don‚Äôt want to. Profiles and User Environments are Nix‚Äôs mechanisms to allow different users to use different configurations.</p>
<p>Derivation
A Derivation is a Nix expression describing everything that goes into a package build action (build tools, dependencies, sources, build scripts, environment variables). It is anything needed to build up a package</p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
